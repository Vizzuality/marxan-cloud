import { CHUNK_SIZE_FOR_BATCH_GEODB_OPERATIONS } from '@marxan-geoprocessing/utils/chunk-size-for-batch-geodb-operations';
import { ScenariosPuCostDataGeo } from '@marxan/scenarios-planning-unit';
import { Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { chunk } from 'lodash';
import { EntityManager, In } from 'typeorm';
import { CostSurfacePersistencePort } from '../ports/persistence/cost-surface-persistence.port';
import { PlanningUnitCost } from '../ports/planning-unit-cost';

@Injectable()
export class TypeormCostSurface implements CostSurfacePersistencePort {
  constructor(
    @InjectEntityManager() private readonly entityManager: EntityManager,
  ) {}

  async save(values: PlanningUnitCost[]): Promise<void> {
    await this.entityManager.transaction(async (em) => {
      await Promise.all(
        chunk(values, CHUNK_SIZE_FOR_BATCH_GEODB_OPERATIONS).map(
          async (rows) => {
            const ids = rows.map((row) => row.id);
            await em.delete(ScenariosPuCostDataGeo, {
              scenariosPuDataId: In(ids),
            });
            await em.insert(
              ScenariosPuCostDataGeo,
              rows.map((row) => ({
                cost: row.cost,
                scenariosPuDataId: row.id,
              })),
            );
          },
        ),
      );
    });
  }

  async generateInitialCostSurface(scenarioId: string): Promise<void> {
    /**
     * Beware: here we set PU cost after rounding PU area to the nearest square
     * km value. This is ok when we generate grids from a GADM area or from a
     * user-supplied planning area, as the frontend app only allows to specify
     * integer values for square km areas for grid generation in any case (the
     * API however would accept a float if used directly, however).
     *
     * Therefore, in the case of grids generated from user settings in the app,
     * the rounding applied here will lead to the expected result (taking into
     * account tiny discrepancies in actual PU areas generated by PostGIS,
     * depending on PU area, location on the Earth spheroid, extent of the
     * planning area, PostGIS version, etc.).
     *
     * When users do supply their own grid, instead, they may wish to keep
     * fractional differences in PU areas to be kept intact when setting initial
     * PU cost. In this case, we would need to differentiate whether a grid is
     * supplied by the user or generated by PostGIS.
     *
     * As we expect sub-square km precision to be rarely needed in general for
     * initial cost surfaces, we keep here the rounding by default, with the
     * caveat that if this precision needs to be added to the platform in the
     * future, we will need to differentiate between user-supplied or
     * programmatic origin of grids.
     *
     * In the meanwhile, users can upload custom cost surfaces after a project
     * has been created in order to override the rounded values in the initial
     * cost values set here.
     */
    await this.entityManager.query(
      `
        INSERT INTO scenarios_pu_cost_data (scenarios_pu_data_id, cost)
        SELECT spd.id, round(pug.area / 1000000) as area
        FROM scenarios_pu_data spd
          INNER JOIN projects_pu ppu ON ppu.id = spd.project_pu_id
          INNER JOIN planning_units_geom pug ON pug.id = ppu.geom_id
        WHERE scenario_id = $1
      `,
      [scenarioId],
    );
  }
}
