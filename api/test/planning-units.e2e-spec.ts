import { Test, TestingModule } from '@nestjs/testing';
import {HttpStatus, INestApplication, Logger, ValidationPipe } from '@nestjs/common';
import * as config from 'config';
import * as request from 'supertest';
import * as IORedis from 'ioredis';
import { Redis } from 'ioredis';
import * as JSONAPISerializer from 'jsonapi-serializer';

import { AppModule } from './../src/app.module';
import { E2E_CONFIG } from './e2e.config';

import { CreateProjectDTO } from 'modules/projects/dto/create.project.dto';
import { Job, Worker } from 'bullmq';
import { PlanningUnitsService } from 'modules/planning-units/planning-units.service';
import { notContains } from 'class-validator';

const logger: Logger = new Logger('tests-planning-units')
function delay(ms: number) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}
/**
 * Create a BullMQ processor function, passing a DTO of generic type T.
 *
 * This can then be
 */
function createProcessor<T>(dto: T) {
  return jest.fn().mockImplementation(async (job: Job) => {
    /**
     * @note Assertions here will succeed or fail, but this should not affect
     * the actual Jest tests that spawn workers because all of this is running
     * in a separate process.
     *
     * Failing assertions should however lead to the `data` property of the hash
     * for this job in Redis to contain a string rendering of any errors
     * generated by failing assertions.
     *
     * So one possible way to test that workers are behaving correctly may be to
     * read back the job hash from Redis and check for any errors there
     * (probably a bit of a crude way, and maybe potentially brittle).
     *
     * Or pack errors in an object returned by the worker, which could then be
     * retrieved in the test itself by listening to the 'completed' event on the
     * worker (`worker.on('completed', (...) => {...})`), and then asserting
     * something in this callback.
     */
    expect(job.data).toStrictEqual(dto);

    /**
     * An example of progress function (and of a possible use below) from within
     * a worker.
     */
    async function updateProgress(
      percent: number,
      delayMilliseconds: number = 100,
    ): Promise<void> {
      await delay(delayMilliseconds);
      job.updateProgress(percent);
    }

    /**
     * Here we create an array of ten promises, each of which is an instance of
     * `updateProgress()` set with a specific completion percent value and
     * (optionally) delay in milliseconds.
     *
     * The promises are then resolved sequentially by awaiting each one.
     *
     * All of this needs to happen between the Jest timeout set for a test or
     * suite, or the test will fail because of not completing within the
     * allotted timeframe. The worker process should however keep working as
     * expected (so for example setting a tick delay of 10e3 will allow to
     * easily follow the progress updates in the Redis hash for the job, though
     * the test itself will fail).
     */
    const progressTicks = [
      ...Array(10).keys(),
    ].map(async (_item, index) => () => updateProgress((index + 1) * 10, 50));
    for await (const tick of progressTicks) {
      await tick();
    }
  });
}
export async function removeAllQueueData(
  client: Redis,
  queueName: string,
  prefix = 'bull',
) {
  const pattern = `${prefix}:${queueName}:*`;
  return new Promise<void>((resolve, reject) => {
    const stream = client.scanStream({
      match: pattern,
    });
    stream.on('data', (keys: string[]) => {
      if (keys.length) {
        const pipeline = client.pipeline();
        keys.forEach(key => {
          pipeline.del(key);
        });
        pipeline.exec().catch(error => {
          reject(error);
        });
      }
    });
    stream.on('end', () => {
      resolve();
    });
    stream.on('error', error => {
      reject(error);
    });
  });
}

describe('PlanningUnitsModule (e2e)', () => {
  let app: INestApplication;
  let queueService: PlanningUnitsService = new PlanningUnitsService;
  let jwtToken: string;
  const Deserializer = new JSONAPISerializer.Deserializer({
    keyForAttribute: 'camelCase',
  });

  /**
   * Set to true if queue data should be removed after each run (see
   * `afterEach()` below). Keeping in mind that long-running workers may still
   * be writing to Redis after tests have run, so there may still be new data
   * showing up in Redis.
   */
  const removeQueueData = false;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();

    app.useGlobalPipes(
      new ValidationPipe({
        transform: true,
        whitelist: true,
        forbidNonWhitelisted: true,
      }),
    );
    await app.init();

    const response = await request(app.getHttpServer())
      .post('/auth/sign-in')
      .send({
        username: E2E_CONFIG.users.basic.aa.username,
        password: E2E_CONFIG.users.basic.aa.password,
      })
      .expect(201);

    jwtToken = response.body.accessToken;
    /**
     * Create an organization for all of the projects in the test suite.
     *
     * No need to assert much here, though we may want to halt the execution
     * of the test suite if the organization cannot be created for whatever
     * reason.
     */
    // anOrganization = await OrganizationsTestUtils.createOrganization(
    //   app,
    //   jwtToken,
    //   E2E_CONFIG.organizations.valid.minimal(),
    // ).then(async (response) => {
    //   return await Deserializer.deserialize(response);
    // });

  });

  afterEach(async function() {
    if (removeQueueData) {
      logger.debug('Removing all queue data.');
      await removeAllQueueData(
        new IORedis(config.get('redisApi.connection')),
        queueService.queueName,
      );
    }
  });

  afterAll(async () => {
    // /**
    //  * On teardown, delete the organization created for the test suite's
    //  * projects.
    //  */
    // await OrganizationsTestUtils.deleteOrganization(
    //   app,
    //   jwtToken,
    //   anOrganization.id,
    // );

    await Promise.all([app.close(), queueService.onModuleDestroy()]);
  });

  describe.only('Planning units', () => {
    let anOrganization: { id: string; type: 'organizations' };
    let minimalProject: { id: string; type: 'projects' };
    let customAreaProject: { id: string; type: 'projects' };
    let adminAreaProject: { id: string; type: 'projects' };

    /**
     * @description
     * this should describe how the sinergy between Project creation
     * and pu creation works
     */

    it('Creates an organization', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/v1/organizations')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send(E2E_CONFIG.organizations.valid.minimal())
        .expect(201);

      anOrganization = response.body.data;

      expect(anOrganization.type).toBe('organizations');
    });

    it('Creates a project with minimum required data, it should succeed but a job should not be created', async () => {
      const createProjectDTO: Partial<CreateProjectDTO> = {
        ...E2E_CONFIG.projects.valid.minimal(),
        organizationId: anOrganization.id,
      };

      let processor = jest.fn().mockImplementation(async (job: Job) => {
        expect(job.data.countryId).toBe(createProjectDTO.countryId);
        delay(50).then(() => {
            return 42;
          });
        });

        const worker = new Worker(
          queueService.queueName,
          processor,
          config.get('redisApi'),
        );

      await worker.waitUntilReady();

      const response = await request(app.getHttpServer())
        .post('/api/v1/projects')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send(createProjectDTO)
        .expect(201);

      const resources = response.body.data;
      minimalProject = resources;
      expect(resources.type).toBe('projects');
      await processor
      expect(processor).not.toHaveBeenCalled();
      await worker.close();
      await worker.disconnect();
    });

    it('Creating a project with custom area should succeed and create a job for that area', async () => {
      const createProjectDTO: Partial<CreateProjectDTO> = {
        ...E2E_CONFIG.projects.valid.customArea({ countryCode: 'NAM' }),
        organizationId: anOrganization.id,
      };
      const processor = createProcessor(createProjectDTO);

      const worker: Worker = new Worker(
        queueService.queueName,
        processor,
        config.get('redisApi'),
      );

      await worker.waitUntilReady();

      const response = await request(app.getHttpServer())
        .post('/api/v1/projects')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send(createProjectDTO)
        .expect(HttpStatus.CREATED);

      const resources = response.body.data;
      customAreaProject = resources;
      expect(resources.type).toBe('projects');

      await Promise.all([delay(1000)]);
      expect(processor).toHaveBeenCalled();
      await worker.close();
      await worker.disconnect();

    });

    it('Creating a project with administrative region data should succeed and create a job for that adm area', async () => {
      // jest.setTimeout(3 * 1000);

      const createProjectDTO: Partial<CreateProjectDTO> = {
        ...E2E_CONFIG.projects.valid.adminRegion({ countryCode: 'NAM' }),
        organizationId: anOrganization.id,
      };
      const processor = createProcessor(createProjectDTO);

      const worker: Worker = new Worker(
        queueService.queueName,
        processor,
        config.get('redisApi'),
      );

      await worker.waitUntilReady();

      const response = await request(app.getHttpServer())
        .post('/api/v1/projects')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send(createProjectDTO)
        .expect(HttpStatus.CREATED);

      const resources = response.body.data;
      customAreaProject = resources;
      expect(resources.type).toBe('projects');

      await Promise.all([delay(1000)]);
      expect(processor).toHaveBeenCalled();
      await worker.close();
      await worker.disconnect();
        });
      /**
       * Finally, we delete the projects we had created to test PU creation
       */
    it('Deleting existing projects should succeed', async () => {
      const response1 = await request(app.getHttpServer())
        .delete(`/api/v1/projects/${minimalProject.id}`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);

      expect(response1.body.data).toBeUndefined();

      const response2 = await request(app.getHttpServer())
        .delete(`/api/v1/projects/${customAreaProject.id}`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);

      expect(response2.body.data).toBeUndefined();

      const response3 = await request(app.getHttpServer())
        .delete(`/api/v1/projects/${adminAreaProject.id}`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);

      expect(response3.body.data).toBeUndefined();

      /**
       * Finally, we delete the organization we had created for these projects
       */
      await request(app.getHttpServer())
        .delete(`/api/v1/organizations/${anOrganization.id}`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });
  });
});
