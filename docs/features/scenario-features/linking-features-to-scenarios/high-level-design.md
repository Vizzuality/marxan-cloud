# Linking features to scenarios - refactor - High-level design

The initial MarxanCloud data model links features (species or bioregional) to
scenarios via the `(geodb)scenario_features_data`, which references the
`(geodb)features_data` table via a foreign key, and the `(apidb)scenarios` table
via plain UUID (no constraint is enforced as the reference is across database
boundaries).

Although this setup is suitable for the preparation of Marxan input files, a
refactor is needed in order to enable to reliably link features to scenarios
when cloning scenarios or exporting/importing projects.

## Limitations of the current design

Platform-wide features and user-uploaded features are both listed in the
`(apidb)features` table.

For platform-wide features, `(apidb)features.project_id` is null (and
`(apidb)features.is_custom` is `false`, as a generated column based on the
former).

For user-uploaded features, conversely, `(apidb)features.project_id` references
`(apidb)projects.id` and `(apidb)features.is_custom` is `true`.

Features are linked to scenarios in the `geodb` database:

- for each `(apidb)features` record, there will be one or more
  `(geodb)features_data` records, where `(geodb)features_data.feature_id`
  "references" `(apidb)features.id`.

- when a feature is used in a scenario, its relevant `(geodb)features_data`
  records are linked to the scenario via `(geodb)scenario_features_data` records

Feature metadata is therefore exported at project level, whereas the links
between specific features and each scenario of a project (alongside Marxan
parameters such as `prop` and `fpf` for each feature selected in a scenario) are
exported at scenario level.

Since scenario export pieces always run _after_ the relevant project export
pieces (and likewise, scenario import pieces always run after project import
pieces), the current design does not allow to retain through a cloning operation
the scenario/feature links that are stored in the source scenarios: all the
`id`s involved in the process are `UUIDv4`s automatically generated by
PostgreSQL at `INSERT` time, and it is therefore impossible to keep the
scenario/feature links through these `id`s only, as they are not stable by
definition across different projects/scenarios (for example, when a project is
duplicated, as the copy of all the `(geodb)features_data` and
`(geodb)scenario_features_data` records will have new, automatically generated
`id`s).

## Aims

The refactor described in this document is limited to the following aims, and
relies on the following assumptions:

- provide stable `id`s that can be reliably referenced within each of an
  arbitrary number of copies of a project and its scenarios, whether in the same
  MarxanCloud instance or across different instances.

- allow to reliably link features to scenarios across cloning operations, both
  for platform-wide and for user-uploaded features.

- projects and their scenarios are locked for edits during the entire duration
  of an export (i.e. since the export process has started and until it
  successfully completes or terminates with errors), and likewise locked for
  edits during the entire duration of an import (i.e. cannot be changed in any
  way until the project being cloned and all its scenarios have been fully
  imported, or until a scenario has been fully imported if the user is cloning
  an individual scenario).

- reliable linking of features to scenarios may be guaranteed only across the
  timespan of a single clone operation (and distinctly for the export and for
  the import sides of it): successive clones of the same project may allow for
  different feature sets to be reliably linked, if features are
  added/deleted/changed in the source project.

- platform-wide features are considered immutable for the purposes of the
  present specification: for the time being, there are no provisions through the
  MarxanCloud API for any traits of features to be changed after their initial
  import via ETL pipelines; as a corollary, if the stable identifier used for a
  platform-wide feature defined in `(apidb)features` (see below:
  `project_id/feature_class_name`) cannot be resolved to a feature in the target
  MarxanCloud instance, if different from the source one, this should be
  considered an error (as all platform-wide features referenced in an exported
  project are required to be available in the target platform)

## Implementation

### Reliably identifying features referenced from feature geometries

1. Features should be guaranteed to be unique either across the space of
   platform-wide features, or across each project.

This can be enforced via partial unique indexes in `apidb`, e.g.

```
create unique index unique_platform_features on features (feature_class_name) where project_id is null;
create unique index unique_project_features on features (feature_class_name, project_id) where project_id is not null;
```

2. *At export time*, a unique combined `project_id/feature_class_name` stable
   identifier, using the nil uuid (`00000000-0000-0000-0000-000000000000`) for
   platform-wide features, should be added to the exported `(apidb)features`
   rows via the export piece for project features; this identifier is then used
   to reference `(apidb)features` in the export piece for scenario features.

For example, such `id`s will look like
`00000000-0000-0000-0000-000000000000/equus_quagga` or
`457e033b-e065-46fe-ae34-d4749b834a09/equus_quagga`.

These identifiers are expected to be stable:

- for platform-wide features, their `feature_class_name` is not meant to ever change
- for user-uploaded features, their `feature_class_name` is guaranteed to be
  stable throughout an export or import step of a clone operation, thanks to
  locks in place to prevent editing projects being exported or imported

3. *At project export time*, the generated export data for
   `(geodb)features_data` should then _also_ reference the combined
   `project_id/feature_class_name` identifier added at export time to
   `(apidb)features`.

This should only be done at export time; permanently persisting these
`uuid/feature_class_name` identifiers in `(geodb)features_data` would
essentially duplicate the current role of the `(geodb)features_data.feature_id`
column, and would need additional logic to keep this column in sync with the
`(apidb)features` table, for example in case
`(apidb)features.feature_class_name` is updated.

### Reliably identifying feature geometries from scenarios

The general strategy used here is the introduction of a stable, univocal and
monotonic numeric identifier for each `(geodb)features_data` record linked to a
given `(apidb)feature`, so that rows could be identified and linked between
project-level and scenario-level exported data.

1. Platform `(geodb)features_data` records should be extended to include an
   identity column, through which these records can be ordered and referenced in
   a stable way, for example:

```
alter table features_data add column fdid bigint not null generated always as identity;
create index concurrently features_data_fdid on features_data (feature_id, fdid asc);
```

The index will help in non-trivial cases with selecting `(geodb)features_data`
records sorted by `fdid`.

Incidentally, it may be a good idea to update the
`precompute_feature_property_list()` function (added in migration
`geoprocessing/RefactorExtractDistinctPropsFromFeatures1625042393000`)
beforehand in order to avoid pointless duplicated fan-out of JSON properties
into the `(geodb)feature_properties_kv` table.

2. *At project export time*, a unique combined
   `feature_class_data.feature_id/hash` stable identifier should be added to the
   exported `(geodb)features_data` rows via the export piece for project
   features; this identifier is then used to reference `(geodb)features_data` in
   the export piece for scenario features; this identifier should build 

3. *At scenario export time*, the generated export data for
   `(geodb)scenario_features_data` should include the identifier above in order
   for the import step to be able to reliably link each
   `(geodb)scenario_features_data` row to the corresponding
   `(geodb)features_data` row.
